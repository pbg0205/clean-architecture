# 만들면서 배우는 클린 아키텍쳐

## 01. 계층형 아키텍처의 문제점

### [1] 데이터 베이스 중심의 설계를 유도한다.
  - 행동이 상태를 바꾸는 주체이기 때문에 행동이 비지니스를 이끌어 간다.
  - 계층형 아키텍처에서는 주로 데이터 베이스의 구조를 먼저 생각하고, 이를 토대로 비니지스 로직을 구현한다.
  - ORM 프레임워크와 계층형 아키텍처가 결합하면 비즈니스 규칙을 영속성 관점과 섞고 싶은 유혹을 쉽게 받는다.

<br>

### [2] 지름길을 선택하기 쉬워진다.

- 계층형 아키텍처은 주로 특정 계층 컴포넌트는 같은 계층의 컴포넌트나 아래 계층에 있는 계층에만 접근이 가능하다.
  (e.g. 도메인(Service) -> 영속성(Repository))
- 단순히 이 규칙을 지키기 위해 상위 컴포넌트를 하위로 내릴 경우 **영속성 계층이 컴포넌트들도 인해 너무 비대** 해질 수 있다. 
 (가장 위험한 후보군. Helper 또는 Utility)
  - 깨진 창문 이론 : 과거에 똑같은 전력이 있다면 재차 그렇게 하는 것에 대한 심리적 부담감이 적어지는 현상
- 규칙을 **강제한다** 의 의미는 `해당 규칙이 깨졌을 때 빌드가 실패하도록 만드는 규칙`을 의미한다.

<br>

### [3] 유스케이스를 숨긴다.

- 아키텍처의 큰 장점 중 하나는 유지보수 이다. 기능을 추가하거나 변경할 적절하게 위치를 빠르게 찾는데 도움이 되기 때문이다.
- 하지만, 계층형 아키텍처는 도메인 로직이 여러 계층에 걸쳐 흩어지기 쉽다.
- 또한, 계층형 아키텍처는 도메인 서비스의 너비에 과한 규칙을 강제하기 않아 여러개의 유스케이스를 담당하는 아주 넓은 서비스가 만들어져 
많은 의존성을 갖게 되어 서비스를 테스트하기 유스케이스를 책임지는 서비스를 찾기도 어렵다.
- 이를 그나마 개선할 수 있는 방법은 고도로 특화된 좁은 도메인 서비스를 만든는 것이다. 예를 들어, 단순히 `UserService` 로 명명하지 않고
`RegisterService` 와 같이 작업하는 것 말이다.

<br>

### [4] 동시 작업이 어려워진다.

- "지연되는 소프트웨어에 인력을 더하는 것은 개발을 늦출 뿐이다."
- 코드에 넓은 서비스가 있다면 서로 다른 기능을 동시에 작업하기가 더욱 어렵다. (confilct....😱)


<br><br>

## 02. 의존성 역전하기

### [1] 단일 책임 원칙(SRP)

- 컴포넌트를 변경하는 이유는 오직 하나뿐이어야 한다. 변경할 이유가 한가지라면 어떤 다른 이유로
소프트웨어를 변경하더라도 이 컴포넌트에 대해서 전혀 신경쓸 필요가 없다.
- 또한, 변경 이유는 컴포넌트 간 의존성을 너무 쉽게 전파 시킬 수 있다. (다이어그램에서 가리키는 화살표가 많아지면 여러 컴포넌트의 로직이 무조건 
섞여 변경이 어렵다.)
 
<br>

### [2] 의존성 역전 원칙 (DIP)

- SRP를 고수준에서 적용할 때 상위 계층은 하위 계층들에 비해 변경할 이유가 더 많다. 예를 들어 영속성 계층에 대한 도메인 계층의 의존성 때문에 영속성 계층을 
변경할 때마다 잠재적으로 도메인 계층도 변경해야 한다.
- 코드상의 어떤 의존성이든 그 방향을 바꿀 수(역전시킬 수) 있다.

<br>

### [3] 클린 아키텍처

- 클린 아키텍처에서는 설계가 비즈니스 규칙의 테스트를 요이하게 하고, 비즈니스 규칙은 
프레임워크, DB, UI, 외부 어플리케이션, 인터페이스로 부터 독립적일 수 있어야 한다.
- 도메인 코드가 바깥으로 어떤 의존성도 없어야 함을 의미한다. (이는 DIP를 통해 의존성 방향을 변경할 수 있다.)
- 클린 아키텍처의 중요한 의존성 규칙은 계층 간의 모든 의존성이 안쪽으로 향해야 한다.
- 클린 아키텍처에도 대가가 따른다 도메인 계층이 외부 계층과 분리되어야 하므로 엔티티에 대한 모델을 각 계층에서 유지보수해야 한다.
  (한마디로 좀 번거로울 수 있다 : ORM entity와 도메인 엔티티를 별도로 유지보수해야 한다.)

<br>

### [4] 헥사고날(Hexagonal) 아키텍처

![image](https://user-images.githubusercontent.com/48561660/177806243-edcb690f-cd9b-49b1-ab52-320ae13ca253.png)

- 육각형 안에는 도메인 엔티티와 상호작용하는 유스케이스가 있고 육각형 외부로 향하는 의존성은 없어야 한다.
- 육각형 바깥에는 애플리케이션과 상호작용하는 다양한 어댑터가 있다.
- 어플리케이션 코어와 어댑터들 간의 통신이 가능하려면 애플리케이션 코어가 각가의 포트를 제공해야 한다.
- 이런 아키텍처 스타일을 `포트와 어댑터(ports-and-adapters)` 아키텍처라고도 한다.

<br>

## 03. 코드 구성하기

### [1] 계층 & 기능으로만 패키지 구성의 단점

**`계층 패키지 구성`**

<img width="300" alt="image" src="https://user-images.githubusercontent.com/48561660/178087924-4799e033-909a-4b1b-b20c-9effebe0fdd0.png">

- 애플리케이션의 도메인과 기능(feature)을 구분 짓는 패키지 경계가 없어 연관되지 않은 기능의 클래스의 묶일 수 있다.
- 도메인과 기능이 섞이면 원하는 기능의 변경지점을 찾는데 어려움이 생긴다.
- 애플리케이션의 유스케이스를 제공하는 것을 파악하기 어려워 특정 기능을 찾기 위해 노력해야 한다.

<br>

**`도메인 패키지 구성`**

<img width="278" alt="image" src="https://user-images.githubusercontent.com/48561660/178087982-172b18fc-9dbb-4763-8831-0d943346bcb6.png">

- 각 도메인은 묶으면 외부에서 접근하면 안되는 클래스에 대해 package-private 접근 수준과 결합하면 각 기능 사잉의 불필요한 의존성을 방지할 수 있다.
- 하지만, 아키텍처의 가시성을 떨어뜨린다.
  (박스에 물건들을 분류해놓는 것처럼 컴포넌트의 역할을 묶지 않으면 필요한 클래스를 찾을 때 시간이 더 오래 걸린다.)

<br>

### [2] 아키텍처적으로 표현력 있는 패키지 구조

**`패키지 구조`**

- 최상위 : 유스케이스를 구현한 모듈
  - domain : 도메인 모델
  - application : 도메인 모델을 둘러싼 서비스 계층을 포함
  - adapter : 애플리케이션 계층의 포트를 호출하는 인커밍 어댑터와 애플리케이션 아웃고잉 포트에 대한 구현을 제공

**`장점`**

1. 이 형태의 구조는 `모델-코드갭(model-code-gap)`을 효과적으로 다룰 수 있다.
  - 모델 코드 갭 : 개발 프로젝트에서 아키텍처 코드에 직접적으로 매핑될 수 없는 추상적 개념이다.
  - 만약 패키지 구조와 아키텍처를 반영할 수 없다면 시간이 지나도 코드는 목표하던 아키텍처로부터 멀어진다.

2. DDD 개념에 직접적으로 대응시킬 수 있다.
    - account 상위 패키지는 다른 바운디드 컨텍스트와 통신할 전용 진입점과 포트를 호함하는 바운디드 컨텍스트에 해당된다.  

**`접근 제한자 설정`**

1. application 은 주로 `private-package` 로 설정
   - 어댑터 클래스로 향하는 우발적인 의존성을 제거할 수 있다.
   - 포트(Port)는 외부와 통신해야 하므로 `public` 이어야 한다.

**`구조 그림`**

![image](https://user-images.githubusercontent.com/48561660/178093721-c0eb0874-8c75-4ffc-b260-ae852f7002e8.png)


## 04. 유스케이스 구현하기

### [1] 도메인 모델 구현하기

`Account entity` 구현

- Account 엔티티는 실제 계좌의 스냅샷을 제공한다.
- 한 계좌에 대한 모든 활동(activity)들을 상상 메모리에 한꺼번 올리는 것은 현명한 방법이 아니기 깨문에 Account 엔티티는
ActivityWindow 값 객체(value object)에서 포착한 지난 며칠 혹은 몇 주간의 범위에 해당하는 활동만 보유한다.

### [2] 유스케이스 기반으로 애플리케이션의 비즈니스 로직 작성

`유스케이스 둘러보기`

- 유스케이스는 비즈니스 규칙(business rule)을 검증할 책임이 있다. (저자는 입력 유효성 검증으로 코드가 오염되면 안된다고 한다.)
- 일반적 도메인 객체의 상태를 바꾸고 영속성 어댑터를 통해 구현된 포트로 이 상태를 전달해서 저장될 수 있게 한다.

`입력 유효성 검증`

1. 입력 유효성 검증 책임에 관한 고민
   - 어댑터에서 입력 유효성 검증 책임을 할당하면 다른 SendMoneyUseCase 를 호출하는 다른 어댑터(e.g. controller)에서
   유효성 검증하는 코드를 추가해 유효성 검증에 관한 중복코드가 많아질 수 있다. 중복 코드가 많아진다는 것은 다른 개발자가 같은 로직을 작성하는 도중에
   이전의 유효성 검증과 다른 로직이 발생할 수 있어 유효성 검증 로직에 관한 일관성이 깨질 수 있다.  
   - 그래서 **`어플리케이션 계층(application package)에서 입력 유효성을 검증`** 해야 한다. 그렇지 않을 경우 애플리케이션 코어 바깥에서 유효하지 않는 입력값을
   받아 모델의 상태를 해칠 수 있다.

`생성자의 힘`

1. 빌더 패턴의 한계
- 파라미터가 추가, 삭제 시에 빌더를 호출하는 코드에서 필드를 잊으면 객체 생성시 런타임 에러를 반환한다.
- 하지만 생성자를 사용한다면 새로운 필드를 추가하거나 필드를 삭제할 때마다 컴파일 에러를 반환한다. (그리고 IDE에서 힌트를 보여준다.)

`비즈니스 규칙 검증하기`

- 구문상의 검증(syntactical) : 입력 유효성과 같이 입력 값을 검증하는 것을 의미한다. 구문상의 검증은 Command에서 처리하도록 한다. 
- 의미적인 검증(semantic) : 비즈니스 로직에서 필요한 검증을 뜻한다. 예를 들어, 출금액은 보유 금액보다 더 많이 출금할 수 없는 것처럼 비즈니스적인 검증은
도메인에 로직을 추가하도록 한다.

`읽기 전용 유스케이스`

- 단순 데이터 조회 쿼리의 경우, 애플리케이션 코어 관점에서는 유스케이스로 간주하지 않는다. 유스케이스로 간주되지 않는다면 실제 유스케이스와 구분하기 위해
쿼리로 구현할 수 있다.
- 읽기 전용 쿼리는 쓰기가 가능한 유스케이스와 코드 상에서 명확하게 구분된다. 이와 같은 형태를 CQRS(Command-Query Responsibility Segregation)
이라 한다.