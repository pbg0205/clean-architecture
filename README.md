# 만들면서 배우는 클린 아키텍쳐

## 01. 계층형 아키텍처의 문제점

### [1] 데이터 베이스 중심의 설계를 유도한다.
  - 행동이 상태를 바꾸는 주체이기 때문에 행동이 비지니스를 이끌어 간다.
  - 계층형 아키텍처에서는 주로 데이터 베이스의 구조를 먼저 생각하고, 이를 토대로 비니지스 로직을 구현한다.
  - ORM 프레임워크와 계층형 아키텍처가 결합하면 비즈니스 규칙을 영속성 관점과 섞고 싶은 유혹을 쉽게 받는다.

<br>

### [2] 지름길을 선택하기 쉬워진다.

- 계층형 아키텍처은 주로 특정 계층 컴포넌트는 같은 계층의 컴포넌트나 아래 계층에 있는 계층에만 접근이 가능하다.
  (e.g. 도메인(Service) -> 영속성(Repository))
- 단순히 이 규칙을 지키기 위해 상위 컴포넌트를 하위로 내릴 경우 **영속성 계층이 컴포넌트들도 인해 너무 비대** 해질 수 있다. 
 (가장 위험한 후보군. Helper 또는 Utility)
  - 깨진 창문 이론 : 과거에 똑같은 전력이 있다면 재차 그렇게 하는 것에 대한 심리적 부담감이 적어지는 현상
- 규칙을 **강제한다** 의 의미는 `해당 규칙이 깨졌을 때 빌드가 실패하도록 만드는 규칙`을 의미한다.

<br>

### [3] 유스케이스를 숨긴다.

- 아키텍처의 큰 장점 중 하나는 유지보수 이다. 기능을 추가하거나 변경할 적절하게 위치를 빠르게 찾는데 도움이 되기 때문이다.
- 하지만, 계층형 아키텍처는 도메인 로직이 여러 계층에 걸쳐 흩어지기 쉽다.
- 또한, 계층형 아키텍처는 도메인 서비스의 너비에 과한 규칙을 강제하기 않아 여러개의 유스케이스를 담당하는 아주 넓은 서비스가 만들어져 
많은 의존성을 갖게 되어 서비스를 테스트하기 유스케이스를 책임지는 서비스를 찾기도 어렵다.
- 이를 그나마 개선할 수 있는 방법은 고도로 특화된 좁은 도메인 서비스를 만든는 것이다. 예를 들어, 단순히 `UserService` 로 명명하지 않고
`RegisterService` 와 같이 작업하는 것 말이다.

<br>

### [4] 동시 작업이 어려워진다.

- "지연되는 소프트웨어에 인력을 더하는 것은 개발을 늦출 뿐이다."
- 코드에 넓은 서비스가 있다면 서로 다른 기능을 동시에 작업하기가 더욱 어렵다. (confilct....😱)


<br><br>

## 02. 의존성 역전하기

### [1] 단일 책임 원칙(SRP)

- 컴포넌트를 변경하는 이유는 오직 하나뿐이어야 한다. 변경할 이유가 한가지라면 어떤 다른 이유로
소프트웨어를 변경하더라도 이 컴포넌트에 대해서 전혀 신경쓸 필요가 없다.
- 또한, 변경 이유는 컴포넌트 간 의존성을 너무 쉽게 전파 시킬 수 있다. (다이어그램에서 가리키는 화살표가 많아지면 여러 컴포넌트의 로직이 무조건 
섞여 변경이 어렵다.)
 
<br>

### [2] 의존성 역전 원칙 (DIP)

- SRP를 고수준에서 적용할 때 상위 계층은 하위 계층들에 비해 변경할 이유가 더 많다. 예를 들어 영속성 계층에 대한 도메인 계층의 의존성 때문에 영속성 계층을 
변경할 때마다 잠재적으로 도메인 계층도 변경해야 한다.
- 코드상의 어떤 의존성이든 그 방향을 바꿀 수(역전시킬 수) 있다.

<br>

### [3] 클린 아키텍처

- 클린 아키텍처에서는 설계가 비즈니스 규칙의 테스트를 요이하게 하고, 비즈니스 규칙은 
프레임워크, DB, UI, 외부 어플리케이션, 인터페이스로 부터 독립적일 수 있어야 한다.
- 도메인 코드가 바깥으로 어떤 의존성도 없어야 함을 의미한다. (이는 DIP를 통해 의존성 방향을 변경할 수 있다.)
- 클린 아키텍처의 중요한 의존성 규칙은 계층 간의 모든 의존성이 안쪽으로 향해야 한다.
- 클린 아키텍처에도 대가가 따른다 도메인 계층이 외부 계층과 분리되어야 하므로 엔티티에 대한 모델을 각 계층에서 유지보수해야 한다.
  (한마디로 좀 번거로울 수 있다 : ORM entity와 도메인 엔티티를 별도로 유지보수해야 한다.)

<br>

### [4] 헥사고날(Hexagonal) 아키텍처

![image](https://user-images.githubusercontent.com/48561660/177806243-edcb690f-cd9b-49b1-ab52-320ae13ca253.png)

- 육각형 안에는 도메인 엔티티와 상호작용하는 유스케이스가 있고 육각형 외부로 향하는 의존성은 없어야 한다.
- 육각형 바깥에는 애플리케이션과 상호작용하는 다양한 어댑터가 있다.
- 어플리케이션 코어와 어댑터들 간의 통신이 가능하려면 애플리케이션 코어가 각가의 포트를 제공해야 한다.
- 이런 아키텍처 스타일을 `포트와 어댑터(ports-and-adapters)` 아키텍처라고도 한다.

<br>
