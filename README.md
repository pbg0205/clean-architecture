# 만들면서 배우는 클린 아키텍쳐

## 01. 계층형 아키텍처의 문제점

### [1] 데이터 베이스 중심의 설계를 유도한다.
  - 행동이 상태를 바꾸는 주체이기 때문에 행동이 비지니스를 이끌어 간다.
  - 계층형 아키텍처에서는 주로 데이터 베이스의 구조를 먼저 생각하고, 이를 토대로 비니지스 로직을 구현한다.
  - ORM 프레임워크와 계층형 아키텍처가 결합하면 비즈니스 규칙을 영속성 관점과 섞고 싶은 유혹을 쉽게 받는다.

<br>

### [2] 지름길을 선택하기 쉬워진다.

- 계층형 아키텍처은 주로 특정 계층 컴포넌트는 같은 계층의 컴포넌트나 아래 계층에 있는 계층에만 접근이 가능하다.
  (e.g. 도메인(Service) -> 영속성(Repository))
- 단순히 이 규칙을 지키기 위해 상위 컴포넌트를 하위로 내릴 경우 **영속성 계층이 컴포넌트들도 인해 너무 비대** 해질 수 있다. 
 (가장 위험한 후보군. Helper 또는 Utility)
  - 깨진 창문 이론 : 과거에 똑같은 전력이 있다면 재차 그렇게 하는 것에 대한 심리적 부담감이 적어지는 현상
- 규칙을 **강제한다** 의 의미는 `해당 규칙이 깨졌을 때 빌드가 실패하도록 만드는 규칙`을 의미한다.

<br>

### [3] 유스케이스를 숨긴다.

- 아키텍처의 큰 장점 중 하나는 유지보수 이다. 기능을 추가하거나 변경할 적절하게 위치를 빠르게 찾는데 도움이 되기 때문이다.
- 하지만, 계층형 아키텍처는 도메인 로직이 여러 계층에 걸쳐 흩어지기 쉽다.
- 또한, 계층형 아키텍처는 도메인 서비스의 너비에 과한 규칙을 강제하기 않아 여러개의 유스케이스를 담당하는 아주 넓은 서비스가 만들어져 
많은 의존성을 갖게 되어 서비스를 테스트하기 유스케이스를 책임지는 서비스를 찾기도 어렵다.
- 이를 그나마 개선할 수 있는 방법은 고도로 특화된 좁은 도메인 서비스를 만든는 것이다. 예를 들어, 단순히 `UserService` 로 명명하지 않고
`RegisterService` 와 같이 작업하는 것 말이다.

<br>

### [4] 동시 작업이 어려워진다.

- "지연되는 소프트웨어에 인력을 더하는 것은 개발을 늦출 뿐이다."
- 코드에 넓은 서비스가 있다면 서로 다른 기능을 동시에 작업하기가 더욱 어렵다. (confilct....😱)
